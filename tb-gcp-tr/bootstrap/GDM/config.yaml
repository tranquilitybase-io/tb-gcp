imports:
  - path: project.py
  - path: apis.py
  - path: service-accounts.py
  - path: network-template.py
  - path: vm-template.py
  - path: cloud-storage-bucket.py
  - path: IAM-policy.py
  - path: nat-gateway.py
  - path: sub-network.py

resources:
  # The "name" property below will be the ID of the new project
  # If you want your project to have a different name, use the "project-name"
  # property.
  - name: deployment-template-53427
    type: project.py
    properties:
      # Change this to your organization ID.
      # You can also create the project in a folder.
      # If both organization-id and parent-folder-id are provided,
      # the project will be created in parent-folder-id.
      parent-folder-id: "943956663445"
      project: deployment-template-53427
      region: europe-west2
      zone: europe-west2-a
      machineType: n1-standard-4
      concurrent_api_activation: False




      # Change the following to your organization's billing account
      billing-account-name: billingAccounts/[BILLING_ACCOUNT_ID]

      # The apis to enable in the new project.
      # To see the possible APIs, use: gcloud services list --available
      apis:
        - appengine.googleapis.com
        - bigquery-json.googleapis.com
        - cloudkms.googleapis.com
        - container.googleapis.com
        - containerregistry.googleapis.com
        - datastore.googleapis.com
        - iap.googleapis.com
        - iam.googleapis.com
        - logging.googleapis.com
        - oslogin.googleapis.com
        - serviceusage.googleapis.com
        - sqladmin.googleapis.com
        - storage-api.googleapis.com
        - sourcerepo.googleapis.com
        - deploymentmanager.googleapis.com
        - pubsub.googleapis.com
        - storage-component.googleapis.com
        - monitoring.googleapis.com
        - compute.googleapis.com
        - iamcredentials.googleapis.com
        - cloudbilling.googleapis.com
        - cloudresourcemanager.googleapis.com
        - runtimeconfig.googleapis.com

      # The service accounts you want to create in the project
      service-accounts:
        - my-service-account-1
        - my-service-account-2

      networks:
        - my-network1

      vm:
        - my-vm-1
      startup-script: |
        #!/bin/bash
        exec >> /var/log/bootstrap.log 2>&1

        MAX_ATTEMPTS=10
        DELAY_BETWEEN_ATTEMPTS=60

        export HOME=/root
        apt-get -y install git
        apt-get -y install kubectl

        cd /opt/tb/repo/tb-gcp-tr/landingZone/
        cat <<EOF > input.auto.tfvars
        clusters_master_whitelist_ip = "${clusters_master_whitelist_ip}"
        region = "${region}"
        region_zone = "${region_zone}"
        root_id = "${root_id}"
        root_is_org = "${root_is_org}"
        billing_account_id = "${billing_account_id}"
        tb_discriminator = "${tb_discriminator}"
        terraform_state_bucket_name = "${terraform_state_bucket_name}"
        EOF
        terraform init -backend-config="bucket=${terraform_state_bucket_name}" -backend-config="prefix=landingZone"

        apply_failures=0
        while [ $apply_failures -lt $MAX_ATTEMPTS ]; do
          terraform apply -var-file input.tfvars -auto-approve
          if [ $? -eq 0 ]; then
            echo "Landing Zone successfully deployed."
            break
          fi
          if [ $((apply_failures +1)) -eq $MAX_ATTEMPTS ]; then
            echo "Maximum of $MAX_ATTEMPTS reached. Moving on..."
            break
          fi
          echo "Landing Zone deployment failed."
          apply_failures=$(($apply_failures + 1))
          echo "Retry #$apply_failures starting in $DELAY_BETWEEN_ATTEMPTS seconds."
          sleep $DELAY_BETWEEN_ATTEMPTS
        done

        # Commit current TB terraform code to GCR
        cd /tmp
        gcloud source repos create tb-terraform-code
        gcloud source repos clone tb-terraform-code
        cd /tmp/tb-terraform-code
        rsync -a /opt/tb/repo/ .
        git init
        git add .
        git commit -m "Landing zone terraform script"
        git push -u origin master
      startupScript: |
        #!/bin/bash
        echo 1 > /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

        gcloud components update -q
        gcloud components install beta -q

        cat <<EOF > /usr/local/sbin/health-check-server.py
        #!/usr/bin/python
        from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
        import subprocess

        PORT_NUMBER = 80
        PING_HOST = "www.google.com"

        def connectivityCheck():
            try:
            subprocess.check_call(["ping", "-c", "1", PING_HOST])
            return True
            except subprocess.CalledProcessError as e:
            return False

        #This class will handle any incoming request
        class myHandler(BaseHTTPRequestHandler):
            def do_GET(self):
            if self.path == '/health-check':
                if connectivityCheck():
                self.send_response(200)
                else:
                self.send_response(503)
            else:
                self.send_response(404)


        try:
            server = HTTPServer(("", PORT_NUMBER), myHandler)
            print "Started httpserver on port " , PORT_NUMBER
            #Wait forever for incoming http requests
            server.serve_forever()

        except KeyboardInterrupt:
            print "^C received, shutting down the web server"
            server.socket.close()
        EOF

        nohup python /usr/local/sbin/health-check-server.py >/dev/null 2>&1 &

        #register a runtime config variable for a waiter to complete
        CONFIG_NAME=$(curl http://metadata.google.internal/computeMetadata/v1/instance/attributes/runtime-config -H "Metadata-Flavor: Google")
        VARIABLE_NAME=$(curl http://metadata.google.internal/computeMetadata/v1/instance/attributes/runtime-variable -H "Metadata-Flavor: Google")

        gcloud beta runtime-config configs variables set $VARIABLE_NAME 1 --config-name $CONFIG_NAME


      bucket-export-settings:
        create-bucket: true
        # If using an already existing bucket, specify this
        # bucket: <my bucket name>

      # Makes the service account that Deployment Manager would use in the
      # generated project when making deployments in this new project a
      # project owner.
      set-dm-service-account-as-owner: true
      # The patches to apply to the project's IAM policy. Note that these are
      # always applied as a patch to the project's current IAM policy, not as a
      # diff with the existing properties stored in DM. This means that removing
      # a binding from the 'add' section will not remove the binding on the
      # project during the next update. Instead it must be added to the 'remove'
      # section.
      iam-policy-patch:
        # These are the bindings to add.
        add:
          - role: roles/owner
            members:
              # This is already not on the project, but in case it shows up, let's
              # remove it.
              - serviceAccount:1234567890@cloudservices.gserviceaccount.com
        # The bindings to remove. Note that these are idempotent, in the sense
        # that any binding here that is not actually on the project is considered
        # to have been removed successfully.
        remove:
          - role: roles/iap.tunnelResourceAccessor
            members:
              # This is already not on the project, but in case it shows up, let's
              # remove it.
              - serviceAccount:1234567890@cloudservices.gserviceaccount.com
