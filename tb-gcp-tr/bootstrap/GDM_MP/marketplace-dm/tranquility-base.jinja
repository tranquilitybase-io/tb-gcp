{% import "path_utils.jinja" as path_utils with context %}

{% set project = env["project"] %}
{% set deployment = env["deployment"] %}
{% set name = "%s-vm-tmpl" % env["name"] %}
{% set instanceName = "%s-vm" % deployment %}
{% set zone = properties["zone"] %}
{% set region = zone[:-2] %}
{% set machineType = properties["machineType"] %}
{% set networks = [] %}
{% for network in properties["network"] %}
{% set _ = networks.append(path_utils.networkPath(network)) %}
{% endfor %}
{% set subnetworks = properties["subnetwork"] %}
{% set externalIPs = properties["externalIP"] %}
{% set bootDiskType = properties["bootDiskType"] %}
{% set bootDiskSizeGb = properties["bootDiskSizeGb"] %}
{% set hasExternalIP = externalIPs and externalIPs[0] != "NONE" %}
{# Software status only works if the VM has an external IP. #}
{% set enableStatusWaiter = hasExternalIP %}
{% set canIpForward = properties["ipForward"] == "On" %}
{% set projectNumber = env["project_number"] %}
{% set clustersMasterWhitelistIp = properties["clustersMasterWhitelistIp"] %}
{% set parentFolderId = properties["parentFolderId"] %}
{% set rootId = properties["parentFolderId"] %}
{% set rootIsOrg = "false" %}
{% set vms = [] %}
{% for vm in properties["vm"] %}
{% set _ = vms.append(vm) %}
{% endfor %}
{% set billingAccountId = properties["billingAccountId"] %}
{% set tbDiscriminator = properties["tbDiscriminator"] %}
{% set terraformStateBucketName = properties["terraformStateBucketName"] %}
{% set concurrentApiActivation = properties["concurrentApiActivation"] %}
{% set bootstrapServerServiceAccount = properties["bootstrapServerServiceAccount"] %}
{% set apis = [] %}
{% for api in properties["apis"] %}
{% set _ = apis.append(api) %}
{% endfor %}

resources:

  - name: {{ name }}
    type: project.py
    properties:
      name: {{ name }}
      vms: {{ vms }}
      instanceName: {{ instanceName }}
      sourceImage: https://www.googleapis.com/compute/v1/projects/tbase-ci/global/images/bootstrap-server-master
      billingAccountId: {{ billingAccountId }}
      concurrentApiActivation: {{ concurrentApiActivation }}
      apis: {{ apis }}
      bootstrapServerServiceAccount: {{ bootstrapServerServiceAccount }}
      tbDiscriminator: {{ tbDiscriminator }}
      terraformStateBucketName: {{ terraformStateBucketName }}
      parentFolderId: {{ parentFolderId }}
      rootId: {{ rootId }}
      rootIsOrg: {{ rootIsOrg }}
      region: {{ region }}
      zone: {{ zone }}
      networks:
      {% for network in networks %}
        - {{ network }}
      {% endfor %}
      {% if subnetworks is defined and subnetworks %}
      subnetworks:
      {% for subnetwork in subnetworks %}
        - {{ subnetwork or '' }}
      {% endfor %}
      {% endif %}
      {% if externalIPs is defined and externalIPs %}
      externalIPs:
      {% for externalIP in externalIPs %}
        - {{ externalIP }}
      {% endfor %}
      {% endif %}
      bootDiskType: {{ bootDiskType }}
      bootDiskSizeGb: {{ bootDiskSizeGb }}
      canIpForward: {{ canIpForward }}
      serviceAccounts:
        - bootstrapserver-sa
      machineType: {{ machineType }}
      bucket-export-settings:
        create-bucket: true
        # If using an already existing bucket, specify this
        # bucket: <my bucket name>
      # Makes the service account that Deployment Manager would use in the
      # generated project when making deployments in this new project a
      # project owner.
      set-dm-service-account-as-owner: true
      # The patches to apply to the project's IAM policy. Note that these are
      # always applied as a patch to the project's current IAM policy, not as a
      # diff with the existing properties stored in DM. This means that removing
      # a binding from the 'add' section will not remove the binding on the
      # project during the next update. Instead it must be added to the 'remove'
      # section.
      iam-policy-patch:
        # These are the bindings to add.
        add:
          - role: roles/owner
            members:
              # This is already not on the project, but in case it shows up, let's
              # remove it.
              - serviceAccount:1234567890@cloudservices.gserviceaccount.com
        # The bindings to remove. Note that these are idempotent, in the sense
        # that any binding here that is not actually on the project is considered
        # to have been removed successfully.
        remove:
          - role: roles/iap.tunnelResourceAccessor
            members:
              # This is already not on the project, but in case it shows up, let's
              # remove it.
              - serviceAccount:1234567890@cloudservices.gserviceaccount.com
      apis:
        - appengine.googleapis.com
        - bigquery-json.googleapis.com
        - cloudkms.googleapis.com
        - container.googleapis.com
        - containerregistry.googleapis.com
        - datastore.googleapis.com
        - iap.googleapis.com
        - iam.googleapis.com
        - logging.googleapis.com
        - oslogin.googleapis.com
        - serviceusage.googleapis.com
        - sqladmin.googleapis.com
        - storage-api.googleapis.com
        - sourcerepo.googleapis.com
        - deploymentmanager.googleapis.com
        - pubsub.googleapis.com
        - storage-component.googleapis.com
        - monitoring.googleapis.com
        - compute.googleapis.com
        - iamcredentials.googleapis.com
        - cloudbilling.googleapis.com
        - cloudresourcemanager.googleapis.com
        - runtimeconfig.googleapis.com
      bootstrapServerStartupScript: |
        #!/bin/bash
        exec >> /var/log/bootstrap.log 2>&1

        MAX_ATTEMPTS=10
        DELAY_BETWEEN_ATTEMPTS=60

        export HOME=/root
        apt-get -y install git
        apt-get -y install kubectl

        cd /opt/tb/repo/tb-gcp-tr/landingZone/
        cat <<EOF > input.auto.tfvars
        clusters_master_whitelist_ip = "{{ clustersMasterWhitelistIp }}"
        region = "{{ region }}"
        region_zone = "{{ region_zone}}"
        root_id = "{{ root_id }}"
        root_is_org = "{{ root_is_org }}"
        billing_account_id = "{{ billingAccountId }}"
        tb_discriminator = "{{ tbDiscriminator }}"
        terraform_state_bucket_name = "{{ terraformStateBucketName }}"
        EOF
        # terraform init -backend-config="bucket={{ terraformStateBucketName }}" -backend-config="prefix=landingZone"

        # apply_failures=0
        # while [ $apply_failures -lt $MAX_ATTEMPTS ]; do
        # terraform apply -var-file input.tfvars -auto-approve
        # if [ $? -eq 0 ]; then
        # echo "Landing Zone successfully deployed."
        # break
        # fi
        # if [ $((apply_failures +1)) -eq $MAX_ATTEMPTS ]; then
        # echo "Maximum of $MAX_ATTEMPTS reached. Moving on..."
        # break
        # fi
        # echo "Landing Zone deployment failed."
        # apply_failures=$(($apply_failures + 1))
        # echo "Retry #$apply_failures starting in $DELAY_BETWEEN_ATTEMPTS seconds."
        # sleep $DELAY_BETWEEN_ATTEMPTS
        # done

        # Commit current TB terraform code to GCR
        # cd /tmp
        # gcloud source repos create tb-terraform-code
        # gcloud source repos clone tb-terraform-code
        # cd /tmp/tb-terraform-code
        # rsync -a /opt/tb/repo/ .
        # git init
        # git add .
        # git commit -m "Landing zone terraform script"
        # git push -u origin master
      natGatewayStartupScript: |
        #!/bin/bash
        echo 1 > /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

        gcloud components update -q
        gcloud components install beta -q

        cat <<EOF > /usr/local/sbin/health-check-server.py
        #!/usr/bin/python
        from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
        import subprocess

        PORT_NUMBER = 80
        PING_HOST = "www.google.com"

        def connectivityCheck():
          try:
          subprocess.check_call(["ping", "-c", "1", PING_HOST])
          return True
          except subprocess.CalledProcessError as e:
          return False

        #This class will handle any incoming request
        class myHandler(BaseHTTPRequestHandler):
          def do_GET(self):
          if self.path == '/health-check':
            if connectivityCheck():
            self.send_response(200)
            else:
            self.send_response(503)
          else:
            self.send_response(404)


        try:
          server = HTTPServer(("", PORT_NUMBER), myHandler)
          print "Started httpserver on port " , PORT_NUMBER
          #Wait forever for incoming http requests
          server.serve_forever()

        except KeyboardInterrupt:
          print "^C received, shutting down the web server"
          server.socket.close()
        EOF

        nohup python /usr/local/sbin/health-check-server.py >/dev/null 2>&1 &

        #register a runtime config variable for a waiter to complete
        CONFIG_NAME=$(curl http://metadata.google.internal/computeMetadata/v1/instance/attributes/runtime-config -H "Metadata-Flavor: Google")
        VARIABLE_NAME=$(curl http://metadata.google.internal/computeMetadata/v1/instance/attributes/runtime-variable -H "Metadata-Flavor: Google")

        gcloud beta runtime-config configs variables set $VARIABLE_NAME 1 --config-name $CONFIG_NAME
outputs:
  - name: deployment
    value: {{ deployment }}
  - name: project
    value: {{ project }}
